# TODO
# negative hex or octal etc?
# Check dashprint conditions and test if calling second flag works.
# Check the flagformat prints *infinite loop with new flagbinaries
# if no conversionflag found print only va_arg else print normally.
# rewrite format_prints to dispatcher table
# Make macros (#define) for flag combos.
# Add conditions for combo flags (+width)
# Add functions for length
# Fix floats.
# Add function for precision,

# Test for evals: 
# Flag combos, repeteating 0 or same flag, newline count, memory leaks?

# FLAGSINFO: 
# 0 is ignored when - is there
# SPACE is ignored when + is there.
# + and SPACE is ignored when # is there
# possible combos:
# 0+#

#### FLAG COMBOS #### "# 0 - + 'space' "
# FLAG: 0 [only with diouxXf](#, -, + and space is error)
# FLAG: # / 0 or - [only with oxXf conversion](+ and space is error)
# FLAG: - / # or space [works with csp too](0 is ignored and + is error)
# FLAG: + / 0 or - and [only with dif conversion]('space',# and oxX is error)
# FLAG: space / - or 0 [csp only works with space- else works for diouf](+, # and conversion oxX is error)
# 0 is always ignored if - is there.
# if isdigit then no more flags and next is [width] or error.

# define flag combos: 2 combo per flag
# 0
# #0
# #-
# -#
# -space
# +0
# +-
# space-
# space0

# flag combos with bits?
# 0

# #-
# #0
# +-
# +0
# space-
# space0

Allowed functions: 
write
malloc
free
exit
man 3 stdarg

Makefile should compile libftprintf.a 
no buffer management in the function

prototype:
int ft_printf(const char *format, ...); ?? 
- %[flags][width][.precision][length]specifier

format âˆ’ This is the string that contains the text to be written to stdout. 
It can optionally contain embedded format tags that are replaced by the values 
specified in subsequent additional arguments and formatted as requested. 

conversions: 16 normal flags total. if char or %
c - char
s - string
p - pointer address
d - signed integer
i - signed integer
o - signed octal
u - unsigned decimal integer
x - unsigned hexadecimal integer
X - unsigned hexadecimal integer (capital letters)
%% - no arguments expected

# LENGTH: hh

# LENGTH: h - idouxX
# The argument is interpreted as a short int or unsigned short int 
# (only applies to integer specifiers: i, d, o, u, x and X).

# LENGTH: l - idouxX and cs 
# The argument is interpreted as a long int or unsigned long int for integer specifiers (i, d, o, u, x and X), 
# and as a wide character or wide character string for specifiers c and s.

# LENGTH: ll - f
# The argument is interpreted as a long double (only applies to floating point specifiers: e, E, f, g and G).

# LENGTH: L - f

# Flag: # - oxX (0, 0x, 0X) and f (.atleast 1 decimal)
# Used with o, x or X specifiers the value is preceded with 0, 0x or 0X 	    # respectively for values different than zero.
# Used with e, E and f, it forces the written output to contain a decimal point # even if no digits would follow. 
# By default, if no digits follow, no decimal point is written. 
# Used with g or G the result is the same as with e or E but trailing zeros are # not removed.

# Flag: - (add spaces to the left if used with - else to the right) 
# Left-justify within the given field width; Right justification is the default (see width sub-specifier).

# Flag: + 
# only used with i or d
	
# Flag: space
# If no sign is going to be written, a blank space is inserted before the value.

# must manage minimum field-width
# must manage precision (float?)

Return Value
If successful, the total number of characters written is returned. On failure, a negative number is returned.